## 微服务

### 单体架构

应用就是一个项目，一个进程里面允许

+ 优点：开发简单，集中管理，没有分布式损耗
+ 缺点：不好维护，升级困难，无法快速迭代

### 单体架构——优化（垂直拆分）

每个大块，拆分，独立部署和维护

缺点：拆分越多，存储越复杂，系统间重复代码也越多

### 分布式服务

+ 一系列服务组装成系统

+ 独立部署，独立允许
+ 独立开发、维护
+ 分布式管理
+ 强调隔离性

### 微服务架构

微服务架构是用分布式服务拆分业务逻辑，完成解耦的架构模式（架构风格）

微服务是分布式的一种

微服务相比三层架构（UI-BLL-DAL）就是把其中的BLL拆分出来，独立成一个个的服务

拆分：微服务如何拆分，参照DDD（领域驱动设计）

### 微服务架构基础

+ 高可用，服务不能挂掉
+ 可伸缩，高峰期，低峰期，服务能扩展，减少

解决办法：集群（负载均衡）SLB，多台服务器承载压力

### 微服务架构核心

+ 服务发现，怎么发现服务？今天两个服务，明天3个，怎么去发现
+ 负载均衡，怎么调用服务？多个服务器，随机调用？顺序调用？

### 微服务1.0时代（服务注册、发现）

集中式代理——Nginx（单纯负载均衡）

+ 比如某服务A，需要调用服务B，服务B做了集群，有B1,B2,B3
+ 服务A通过Nginx，调用服务B，Nginx决定具体调用哪个服务，
  + 比如轮询，权重等
+ Nginx人工配置的（服务发现问题解决）
+ 调度策略：Nginx根据配置来（负载均衡问题解决）

### 微服务2.0时代（熔断/限流/降级/健康检查等服务治理）

客户端嵌入——Consul/etcd/zookeeper/dubbo...

+ 服务B，现在有三个，每增加一个，都会向Consul注册，然后Consul负责统一管理，记录服务B1，2，3的信息（服务注册与发现）
+ 服务A，每次调用服务B之前，先去Consul拿一下，可能拿一个，也可能拿多个，拿一个，就直接请求，拿多个，具体调度策略就由A自己实现（负载均衡）
+ Consul，通过心跳，检查多个服务B的状态，看看是否正常可以使用（健康检查）
+ 优点：

  + 功能相比1.0强大，自动注册，减少人力，
  + 健康检查，自动减少
+ 缺点：

  + 客户端（服务A）集成复杂（负载均衡实现在服务A），职责重
  + 现实，不止一个服务，而是多个服务，每个服务都要实现负载均衡，很麻烦

### 微服务3.0时代

服务网格——Service Mesh

每个计算机包含一个SideCar，然后通过一个管理页面，同意管理各个计算机

Sidecar与服务一一对应，负责服务注册、发现、负载均衡、限流、熔断。。。

优点：不需要服务独立实现负载均衡、也不需要额外的服务注册发现工具

缺点：系统复杂度提高

### 服务治理——网关Gateway

+ 对服务的管理，什么时候需要增加服务、减少服务、限制服务、关闭服务等

  + 例如双十一，淘宝订单增加，三个月前历史订单禁止查询，这也属于一种服务治理：提高支付服务、降低订单查询服务

+ 在微服务2.0的时候，Consul是无法进行服务治理的，服务自身也是无法实现服务治理的，因为服务不止一个

  + 这时候就需要网关（Gateway）入场了
  + 网关+Consul=》实现微服务

  ![image-20210207201326247](K:/Blog/docs/.vuepress/public/images/image-20210207201326247.png)
  + 网关：上面的一些功能调用网关，网关负责转发

    网关通过映射实现

    与Nginx不同，Nginx只是做负载 

    多个服务，不会对外公开，而是放在内网中，唯一只有网关对外公开，增加安全性

    网关：就是做路由的 

  + 提供统一服务入口，让微服务对前台透明，节省流量，提示性能，提供安全、过滤、流控等API管理功能

  + 缓存：也可以通过网关管理，减少流量

  + 熔断：假设现在用户服务，已经快崩了，几秒返回响应，那么后续请求，网关直接拦截，不再请求用户服务

  + 做鉴权：使用IdentityServer4，是否有权限，有权限则进一步请求服务

  + 限流：单位时间内流量允许多少次

### 践行微服务架构——跨进程通信

+ 共享存储：多个应用，把数据写到一个第三方共享存储（Redis/DB/Queue/硬盘文件）中
  + 被动式通信
  + 门槛低 
+ 服务通信：WebService/WCF/WebApi。。。
  + 主动触发
  + 数据序列化传递
  + 跨平台
  + 跨语言
  + http穿透防火墙
+ RPC：远程进程调用
  + .NET Remoting
  + gRPC：高性能、开源通用框架

### 践行微服务架构——鉴权&授权

IdentityServer4

### 践行微服务架构——瞬态故障处理

 Polly：.NET弹性和瞬态故障处理，允许非常顺畅和线程安全的方式来执行重试、断路、超时、故障恢复等策略

+ 比如当调用一个服务的时候，超时了，根据设置的超时时间，返回超时等等
+ 不是进程，是一个类库， 

### 践行微服务架构——分布式追踪Skywalking

分布式追踪和`APM`的Server端，它将包含Collector，Storage，独立的WebUI，并使用Open Tracing规范来设计追踪数据

+ 调用多个服务的时候，某个服务超时，某个服务挂了，某个服务花时过长等等，这些可以被追踪到
+ 做性能追踪，找出调用路径

### 践行微服务架构——ExceptionLess

开源的日志收集和分析框架，能为应用程序提供实时错误、特性和日志报告

### 践行微服务架构——统一配置中心

Apollo：配置管理平台，能够集中化管理应用不同环境、不同集群的配置，配置修改后能准时推送到应用端，并且具备规范的权限、流程治理等特性

+ 微服务中，配置是必须的，配置信息需要集中管理，不可能每个服务单独做个配置，不方便维护

### 践行微服务架构——分布式事务

+ 保证数据一致性、可用性、容错性等等

![image-20210207224951921](K:/Blog/docs/.vuepress/public/images/image-20210207224951921.png)

### 分布式锁

![image-20210207224930644](K:/Blog/docs/.vuepress/public/images/image-20210207224930644.png)

### 2PC/3PC

![image-20210207225252334](K:/Blog/docs/.vuepress/public/images/image-20210207225252334.png)

### TCC（Try-Confirm-Cancel）

![image-20210207225241374](K:/Blog/docs/.vuepress/public/images/image-20210207225241374.png)

### 本地消息表

![image-20210207225310007](K:/Blog/docs/.vuepress/public/images/image-20210207225310007.png)

### 其他

![image-20210207225338361](K:/Blog/docs/.vuepress/public/images/image-20210207225338361.png)

### 践行微服务架构——容器化

docker：容器

### 践行微服务架构——容器编排k8s

管理应用的全生命周期工具，创建应用/部署，扩容缩容，更新，故障痊愈等

### 践行微服务架构——CI/CD

Jenkins：提供友好界面的持续集成（CI）工具，主要用于持续、自动构建/测试软件项目、监控外部任务运行

